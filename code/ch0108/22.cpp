/*
 * @Author: allen
 * @Date: 2023-08-11
 *
 * 22:神奇的幻方
 *
 * 总时间限制: 1000ms 内存限制: 65535kB
 *
 * 描述
 *     幻方是一个很神奇的N*N矩阵，它的每行、每列与对角线，加起来的数字和都是相同的。
我们可以通过以下方法构建一个幻方。（阶数为奇数）
1.第一个数字写在第一行的中间
2.下一个数字，都写在上一个数字的右上方：
    a.如果该数字在第一行，则下一个数字写在最后一行，列数为该数字的右一列
    b.如果该数字在最后一列，则下一个数字写在第一列，行数为该数字的上一行
    c.如果该数字在右上角，或者该数字的右上方已有数字，则下一个数字写在该数字的下方
 *
 * 输入
 *     一个数字N（N<=20）
 *
 * 输出
 *     按上方法构造的2N-1 * 2N-1的幻方
 *
 * 样例输入
 *     3
 *
 * 样例输出
 *     17 24 1 8 15
23 5 7 14 16
4 6 13 20 22
10 12 19 21 3
11 18 25 2 9
 *
 * 提示
 *      
 */
 
#include <iostream>
using namespace std;

int main() {
	int n, i = 0, j = 0, k = 1, size = 0, arr[40][40] = { 0 };
	cin >> n;

	j = n - 1;
	size = (2 * n - 1) * (2 * n - 1);

	arr[i][j] = k;
	k++;
	while (size > 1) {
		if (i == 0 && j != 2 * n - 2) {
			i = 2 * n - 2;
			j = j + 1;
			arr[i][j] = k;
			k++;
		} else if (i !=0 && j == 2 * n - 2) {
			i = i - 1;
			j = 0;
			arr[i][j] = k;
			k++;
		} else if (i == 0 && j == 2 * n - 2 || arr[i - 1][j + 1] != 0) {
			i = i + 1;
			arr[i][j] = k;
			k++; 
		} else {
			i = i - 1;
			j = j + 1;
			arr[i][j] = k;
			k++; 
		} 
		size--;
	}
	for (int x = 0; x < 2 * n - 1; x++) {
		for (int y = 0; y < 2 * n - 1; y++) {
			cout << arr[x][y] << " ";
		} 
		cout << endl;
	} 
	return 0;
} 